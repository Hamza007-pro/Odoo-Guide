"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mobx-react-lite";
exports.ids = ["vendor-chunks/mobx-react-lite"];
exports.modules = {

/***/ "(ssr)/./node_modules/mobx-react-lite/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mobx-react-lite/dist/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./mobxreactlite.cjs.development.js */ \"(ssr)/./node_modules/mobx-react-lite/dist/mobxreactlite.cjs.development.js\")\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IjtBQUNZOztBQUVaLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw0SkFBOEQ7QUFDaEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMtb2Rvby1kb2NzLy4vbm9kZV9tb2R1bGVzL21vYngtcmVhY3QtbGl0ZS9kaXN0L2luZGV4LmpzPzkxOTQiXSwic291cmNlc0NvbnRlbnQiOlsiXG4ndXNlIHN0cmljdCdcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL21vYnhyZWFjdGxpdGUuY2pzLnByb2R1Y3Rpb24ubWluLmpzJylcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tb2J4cmVhY3RsaXRlLmNqcy5kZXZlbG9wbWVudC5qcycpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mobx-react-lite/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mobx-react-lite/dist/mobxreactlite.cjs.development.js":
/*!****************************************************************************!*\
  !*** ./node_modules/mobx-react-lite/dist/mobxreactlite.cjs.development.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar mobx = __webpack_require__(/*! mobx */ \"(ssr)/./node_modules/mobx/dist/index.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar React__default = _interopDefault(React);\nvar reactDom = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\nvar shim = __webpack_require__(/*! use-sync-external-store/shim */ \"(ssr)/./node_modules/use-sync-external-store/shim/index.js\");\n\nif (!React.useState) {\n  throw new Error(\"mobx-react-lite requires React with Hooks support\");\n}\nif (!mobx.makeObservable) {\n  throw new Error(\"mobx-react-lite@3 requires mobx at least version 6 to be available\");\n}\n\nfunction defaultNoopBatch(callback) {\n  callback();\n}\nfunction observerBatching(reactionScheduler) {\n  if (!reactionScheduler) {\n    reactionScheduler = defaultNoopBatch;\n    {\n      console.warn(\"[MobX] Failed to get unstable_batched updates from react-dom / react-native\");\n    }\n  }\n  mobx.configure({\n    reactionScheduler: reactionScheduler\n  });\n}\nvar isObserverBatched = function isObserverBatched() {\n  {\n    console.warn(\"[MobX] Deprecated\");\n  }\n  return true;\n};\n\nvar deprecatedMessages = [];\nfunction useDeprecated(msg) {\n  if (!deprecatedMessages.includes(msg)) {\n    deprecatedMessages.push(msg);\n    console.warn(msg);\n  }\n}\n\nfunction printDebugValue(v) {\n  return mobx.getDependencyTree(v);\n}\n\nvar globalIsUsingStaticRendering = false;\nfunction enableStaticRendering(enable) {\n  globalIsUsingStaticRendering = enable;\n}\nfunction isUsingStaticRendering() {\n  return globalIsUsingStaticRendering;\n}\n\nvar REGISTRY_FINALIZE_AFTER = 10000;\nvar REGISTRY_SWEEP_INTERVAL = 10000;\nvar TimerBasedFinalizationRegistry = /*#__PURE__*/function () {\n  function TimerBasedFinalizationRegistry(finalize) {\n    var _this = this;\n    this.finalize = void 0;\n    this.registrations = new Map();\n    this.sweepTimeout = void 0;\n    this.sweep = function (maxAge) {\n      if (maxAge === void 0) {\n        maxAge = REGISTRY_FINALIZE_AFTER;\n      }\n      // cancel timeout so we can force sweep anytime\n      clearTimeout(_this.sweepTimeout);\n      _this.sweepTimeout = undefined;\n      var now = Date.now();\n      _this.registrations.forEach(function (registration, token) {\n        if (now - registration.registeredAt >= maxAge) {\n          _this.finalize(registration.value);\n          _this.registrations[\"delete\"](token);\n        }\n      });\n      if (_this.registrations.size > 0) {\n        _this.scheduleSweep();\n      }\n    };\n    this.finalizeAllImmediately = function () {\n      _this.sweep(0);\n    };\n    this.finalize = finalize;\n  }\n  // Token is actually required with this impl\n  var _proto = TimerBasedFinalizationRegistry.prototype;\n  _proto.register = function register(target, value, token) {\n    this.registrations.set(token, {\n      value: value,\n      registeredAt: Date.now()\n    });\n    this.scheduleSweep();\n  };\n  _proto.unregister = function unregister(token) {\n    this.registrations[\"delete\"](token);\n  }\n  // Bound so it can be used directly as setTimeout callback.\n  ;\n  _proto.scheduleSweep = function scheduleSweep() {\n    if (this.sweepTimeout === undefined) {\n      this.sweepTimeout = setTimeout(this.sweep, REGISTRY_SWEEP_INTERVAL);\n    }\n  };\n  return TimerBasedFinalizationRegistry;\n}();\nvar UniversalFinalizationRegistry = typeof FinalizationRegistry !== \"undefined\" ? FinalizationRegistry : TimerBasedFinalizationRegistry;\n\nvar observerFinalizationRegistry = /*#__PURE__*/new UniversalFinalizationRegistry(function (adm) {\n  var _adm$reaction;\n  (_adm$reaction = adm.reaction) == null ? void 0 : _adm$reaction.dispose();\n  adm.reaction = null;\n});\n\n// Required by SSR when hydrating #3669\nvar getServerSnapshot = function getServerSnapshot() {};\nfunction createReaction(adm) {\n  adm.reaction = new mobx.Reaction(\"observer\" + adm.name, function () {\n    adm.stateVersion = Symbol();\n    // onStoreChange won't be available until the component \"mounts\".\n    // If state changes in between initial render and mount,\n    // `useSyncExternalStore` should handle that by checking the state version and issuing update.\n    adm.onStoreChange == null ? void 0 : adm.onStoreChange();\n  });\n}\nfunction useObserver(render, baseComponentName) {\n  if (baseComponentName === void 0) {\n    baseComponentName = \"observed\";\n  }\n  if (isUsingStaticRendering()) {\n    return render();\n  }\n  var admRef = React__default.useRef(null);\n  if (!admRef.current) {\n    // First render\n    var _adm = {\n      reaction: null,\n      onStoreChange: null,\n      stateVersion: Symbol(),\n      name: baseComponentName,\n      subscribe: function subscribe(onStoreChange) {\n        // Do NOT access admRef here!\n        observerFinalizationRegistry.unregister(_adm);\n        _adm.onStoreChange = onStoreChange;\n        if (!_adm.reaction) {\n          // We've lost our reaction and therefore all subscriptions, occurs when:\n          // 1. Timer based finalization registry disposed reaction before component mounted.\n          // 2. React \"re-mounts\" same component without calling render in between (typically <StrictMode>).\n          // We have to recreate reaction and schedule re-render to recreate subscriptions,\n          // even if state did not change.\n          createReaction(_adm);\n          // `onStoreChange` won't force update if subsequent `getSnapshot` returns same value.\n          // So we make sure that is not the case\n          _adm.stateVersion = Symbol();\n        }\n        return function () {\n          var _adm$reaction;\n          // Do NOT access admRef here!\n          _adm.onStoreChange = null;\n          (_adm$reaction = _adm.reaction) == null ? void 0 : _adm$reaction.dispose();\n          _adm.reaction = null;\n        };\n      },\n      getSnapshot: function getSnapshot() {\n        // Do NOT access admRef here!\n        return _adm.stateVersion;\n      }\n    };\n    admRef.current = _adm;\n  }\n  var adm = admRef.current;\n  if (!adm.reaction) {\n    // First render or reaction was disposed by registry before subscribe\n    createReaction(adm);\n    // StrictMode/ConcurrentMode/Suspense may mean that our component is\n    // rendered and abandoned multiple times, so we need to track leaked\n    // Reactions.\n    observerFinalizationRegistry.register(admRef, adm, adm);\n  }\n  React__default.useDebugValue(adm.reaction, printDebugValue);\n  shim.useSyncExternalStore(\n  // Both of these must be stable, otherwise it would keep resubscribing every render.\n  adm.subscribe, adm.getSnapshot, getServerSnapshot);\n  // render the original component, but have the\n  // reaction track the observables, so that rendering\n  // can be invalidated (see above) once a dependency changes\n  var renderResult;\n  var exception;\n  adm.reaction.track(function () {\n    try {\n      renderResult = render();\n    } catch (e) {\n      exception = e;\n    }\n  });\n  if (exception) {\n    throw exception; // re-throw any exceptions caught during rendering\n  }\n\n  return renderResult;\n}\n\nvar warnObserverOptionsDeprecated = true;\nvar hasSymbol = typeof Symbol === \"function\" && Symbol[\"for\"];\n// Using react-is had some issues (and operates on elements, not on types), see #608 / #609\nvar ReactForwardRefSymbol = hasSymbol ? /*#__PURE__*/Symbol[\"for\"](\"react.forward_ref\") : typeof React.forwardRef === \"function\" && /*#__PURE__*/React.forwardRef(function (props) {\n  return null;\n})[\"$$typeof\"];\nvar ReactMemoSymbol = hasSymbol ? /*#__PURE__*/Symbol[\"for\"](\"react.memo\") : typeof React.memo === \"function\" && /*#__PURE__*/React.memo(function (props) {\n  return null;\n})[\"$$typeof\"];\n// n.b. base case is not used for actual typings or exported in the typing files\nfunction observer(baseComponent,\n// TODO remove in next major\noptions) {\n  var _options$forwardRef;\n  if ( warnObserverOptionsDeprecated && options) {\n    warnObserverOptionsDeprecated = false;\n    console.warn(\"[mobx-react-lite] `observer(fn, { forwardRef: true })` is deprecated, use `observer(React.forwardRef(fn))`\");\n  }\n  if (ReactMemoSymbol && baseComponent[\"$$typeof\"] === ReactMemoSymbol) {\n    throw new Error(\"[mobx-react-lite] You are trying to use `observer` on a function component wrapped in either another `observer` or `React.memo`. The observer already applies 'React.memo' for you.\");\n  }\n  // The working of observer is explained step by step in this talk: https://www.youtube.com/watch?v=cPF4iBedoF0&feature=youtu.be&t=1307\n  if (isUsingStaticRendering()) {\n    return baseComponent;\n  }\n  var useForwardRef = (_options$forwardRef = options == null ? void 0 : options.forwardRef) != null ? _options$forwardRef : false;\n  var render = baseComponent;\n  var baseComponentName = baseComponent.displayName || baseComponent.name;\n  // If already wrapped with forwardRef, unwrap,\n  // so we can patch render and apply memo\n  if (ReactForwardRefSymbol && baseComponent[\"$$typeof\"] === ReactForwardRefSymbol) {\n    useForwardRef = true;\n    render = baseComponent[\"render\"];\n    if (typeof render !== \"function\") {\n      throw new Error(\"[mobx-react-lite] `render` property of ForwardRef was not a function\");\n    }\n  }\n  var observerComponent = function observerComponent(props, ref) {\n    return useObserver(function () {\n      return render(props, ref);\n    }, baseComponentName);\n  };\n  observerComponent.displayName = baseComponent.displayName;\n  Object.defineProperty(observerComponent, \"name\", {\n    value: baseComponent.name,\n    writable: true,\n    configurable: true\n  });\n  // Support legacy context: `contextTypes` must be applied before `memo`\n  if (baseComponent.contextTypes) {\n    observerComponent.contextTypes = baseComponent.contextTypes;\n  }\n  if (useForwardRef) {\n    // `forwardRef` must be applied prior `memo`\n    // `forwardRef(observer(cmp))` throws:\n    // \"forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))\"\n    observerComponent = React.forwardRef(observerComponent);\n  }\n  // memo; we are not interested in deep updates\n  // in props; we assume that if deep objects are changed,\n  // this is in observables, which would have been tracked anyway\n  observerComponent = React.memo(observerComponent);\n  copyStaticProperties(baseComponent, observerComponent);\n  {\n    Object.defineProperty(observerComponent, \"contextTypes\", {\n      set: function set() {\n        var _this$type, _this$type2;\n        throw new Error(\"[mobx-react-lite] `\" + (this.displayName || ((_this$type = this.type) == null ? void 0 : _this$type.displayName) || ((_this$type2 = this.type) == null ? void 0 : _this$type2.name) || \"Component\") + \".contextTypes` must be set before applying `observer`.\");\n      }\n    });\n  }\n  return observerComponent;\n}\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\nvar hoistBlackList = {\n  $$typeof: true,\n  render: true,\n  compare: true,\n  type: true,\n  // Don't redefine `displayName`,\n  // it's defined as getter-setter pair on `memo` (see #3192).\n  displayName: true\n};\nfunction copyStaticProperties(base, target) {\n  Object.keys(base).forEach(function (key) {\n    if (!hoistBlackList[key]) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));\n    }\n  });\n}\n\nfunction ObserverComponent(_ref) {\n  var children = _ref.children,\n    render = _ref.render;\n  var component = children || render;\n  if (typeof component !== \"function\") {\n    return null;\n  }\n  return useObserver(component);\n}\n{\n  ObserverComponent.propTypes = {\n    children: ObserverPropsCheck,\n    render: ObserverPropsCheck\n  };\n}\nObserverComponent.displayName = \"Observer\";\nfunction ObserverPropsCheck(props, key, componentName, location, propFullName) {\n  var extraKey = key === \"children\" ? \"render\" : \"children\";\n  var hasProp = typeof props[key] === \"function\";\n  var hasExtraProp = typeof props[extraKey] === \"function\";\n  if (hasProp && hasExtraProp) {\n    return new Error(\"MobX Observer: Do not use children and render in the same time in`\" + componentName);\n  }\n  if (hasProp || hasExtraProp) {\n    return null;\n  }\n  return new Error(\"Invalid prop `\" + propFullName + \"` of type `\" + typeof props[key] + \"` supplied to\" + \" `\" + componentName + \"`, expected `function`.\");\n}\n\nfunction useLocalObservable(initializer, annotations) {\n  return React.useState(function () {\n    return mobx.observable(initializer(), annotations, {\n      autoBind: true\n    });\n  })[0];\n}\n\nfunction useAsObservableSource(current) {\n  useDeprecated(\"[mobx-react-lite] 'useAsObservableSource' is deprecated, please store the values directly in an observable, for example by using 'useLocalObservable', and sync future updates using 'useEffect' when needed. See the README for examples.\");\n  var _useState = React.useState(function () {\n      return mobx.observable(current, {}, {\n        deep: false\n      });\n    }),\n    res = _useState[0];\n  mobx.runInAction(function () {\n    Object.assign(res, current);\n  });\n  return res;\n}\n\nfunction useLocalStore(initializer, current) {\n  {\n    useDeprecated(\"[mobx-react-lite] 'useLocalStore' is deprecated, use 'useLocalObservable' instead.\");\n  }\n  var source = current && useAsObservableSource(current);\n  return React.useState(function () {\n    return mobx.observable(initializer(source), undefined, {\n      autoBind: true\n    });\n  })[0];\n}\n\nvar _observerFinalization;\nobserverBatching(reactDom.unstable_batchedUpdates);\nvar clearTimers = (_observerFinalization = observerFinalizationRegistry[\"finalizeAllImmediately\"]) != null ? _observerFinalization : function () {};\nfunction useObserver$1(fn, baseComponentName) {\n  if (baseComponentName === void 0) {\n    baseComponentName = \"observed\";\n  }\n  {\n    useDeprecated(\"[mobx-react-lite] 'useObserver(fn)' is deprecated. Use `<Observer>{fn}</Observer>` instead, or wrap the entire component in `observer`.\");\n  }\n  return useObserver(fn, baseComponentName);\n}\nfunction useStaticRendering(enable) {\n  {\n    console.warn(\"[mobx-react-lite] 'useStaticRendering' is deprecated, use 'enableStaticRendering' instead\");\n  }\n  enableStaticRendering(enable);\n}\n\nexports.Observer = ObserverComponent;\nexports._observerFinalizationRegistry = observerFinalizationRegistry;\nexports.clearTimers = clearTimers;\nexports.enableStaticRendering = enableStaticRendering;\nexports.isObserverBatched = isObserverBatched;\nexports.isUsingStaticRendering = isUsingStaticRendering;\nexports.observer = observer;\nexports.observerBatching = observerBatching;\nexports.useAsObservableSource = useAsObservableSource;\nexports.useLocalObservable = useLocalObservable;\nexports.useLocalStore = useLocalStore;\nexports.useObserver = useObserver$1;\nexports.useStaticRendering = useStaticRendering;\n//# sourceMappingURL=mobxreactlite.cjs.development.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9ieC1yZWFjdC1saXRlL2Rpc3QvbW9ieHJlYWN0bGl0ZS5janMuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RCxnQ0FBZ0M7O0FBRWhDLFdBQVcsbUJBQU8sQ0FBQyxxREFBTTtBQUN6QixZQUFZLG1CQUFPLENBQUMsd0dBQU87QUFDM0I7QUFDQSxlQUFlLG1CQUFPLENBQUMsZ0hBQVc7QUFDbEMsV0FBVyxtQkFBTyxDQUFDLGdHQUE4Qjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixHQUFHO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEIscUNBQXFDO0FBQ3JDLG1CQUFtQjtBQUNuQiw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCLDhCQUE4QjtBQUM5QixnQkFBZ0I7QUFDaEIsd0JBQXdCO0FBQ3hCLDZCQUE2QjtBQUM3QiwwQkFBMEI7QUFDMUIscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQiwwQkFBMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMtb2Rvby1kb2NzLy4vbm9kZV9tb2R1bGVzL21vYngtcmVhY3QtbGl0ZS9kaXN0L21vYnhyZWFjdGxpdGUuY2pzLmRldmVsb3BtZW50LmpzPzY1YzkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIG1vYnggPSByZXF1aXJlKCdtb2J4Jyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJlYWN0X19kZWZhdWx0ID0gX2ludGVyb3BEZWZhdWx0KFJlYWN0KTtcbnZhciByZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xudmFyIHNoaW0gPSByZXF1aXJlKCd1c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltJyk7XG5cbmlmICghUmVhY3QudXNlU3RhdGUpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibW9ieC1yZWFjdC1saXRlIHJlcXVpcmVzIFJlYWN0IHdpdGggSG9va3Mgc3VwcG9ydFwiKTtcbn1cbmlmICghbW9ieC5tYWtlT2JzZXJ2YWJsZSkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJtb2J4LXJlYWN0LWxpdGVAMyByZXF1aXJlcyBtb2J4IGF0IGxlYXN0IHZlcnNpb24gNiB0byBiZSBhdmFpbGFibGVcIik7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHROb29wQmF0Y2goY2FsbGJhY2spIHtcbiAgY2FsbGJhY2soKTtcbn1cbmZ1bmN0aW9uIG9ic2VydmVyQmF0Y2hpbmcocmVhY3Rpb25TY2hlZHVsZXIpIHtcbiAgaWYgKCFyZWFjdGlvblNjaGVkdWxlcikge1xuICAgIHJlYWN0aW9uU2NoZWR1bGVyID0gZGVmYXVsdE5vb3BCYXRjaDtcbiAgICB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbTW9iWF0gRmFpbGVkIHRvIGdldCB1bnN0YWJsZV9iYXRjaGVkIHVwZGF0ZXMgZnJvbSByZWFjdC1kb20gLyByZWFjdC1uYXRpdmVcIik7XG4gICAgfVxuICB9XG4gIG1vYnguY29uZmlndXJlKHtcbiAgICByZWFjdGlvblNjaGVkdWxlcjogcmVhY3Rpb25TY2hlZHVsZXJcbiAgfSk7XG59XG52YXIgaXNPYnNlcnZlckJhdGNoZWQgPSBmdW5jdGlvbiBpc09ic2VydmVyQmF0Y2hlZCgpIHtcbiAge1xuICAgIGNvbnNvbGUud2FybihcIltNb2JYXSBEZXByZWNhdGVkXCIpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIGRlcHJlY2F0ZWRNZXNzYWdlcyA9IFtdO1xuZnVuY3Rpb24gdXNlRGVwcmVjYXRlZChtc2cpIHtcbiAgaWYgKCFkZXByZWNhdGVkTWVzc2FnZXMuaW5jbHVkZXMobXNnKSkge1xuICAgIGRlcHJlY2F0ZWRNZXNzYWdlcy5wdXNoKG1zZyk7XG4gICAgY29uc29sZS53YXJuKG1zZyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnREZWJ1Z1ZhbHVlKHYpIHtcbiAgcmV0dXJuIG1vYnguZ2V0RGVwZW5kZW5jeVRyZWUodik7XG59XG5cbnZhciBnbG9iYWxJc1VzaW5nU3RhdGljUmVuZGVyaW5nID0gZmFsc2U7XG5mdW5jdGlvbiBlbmFibGVTdGF0aWNSZW5kZXJpbmcoZW5hYmxlKSB7XG4gIGdsb2JhbElzVXNpbmdTdGF0aWNSZW5kZXJpbmcgPSBlbmFibGU7XG59XG5mdW5jdGlvbiBpc1VzaW5nU3RhdGljUmVuZGVyaW5nKCkge1xuICByZXR1cm4gZ2xvYmFsSXNVc2luZ1N0YXRpY1JlbmRlcmluZztcbn1cblxudmFyIFJFR0lTVFJZX0ZJTkFMSVpFX0FGVEVSID0gMTAwMDA7XG52YXIgUkVHSVNUUllfU1dFRVBfSU5URVJWQUwgPSAxMDAwMDtcbnZhciBUaW1lckJhc2VkRmluYWxpemF0aW9uUmVnaXN0cnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUaW1lckJhc2VkRmluYWxpemF0aW9uUmVnaXN0cnkoZmluYWxpemUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuZmluYWxpemUgPSB2b2lkIDA7XG4gICAgdGhpcy5yZWdpc3RyYXRpb25zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuc3dlZXBUaW1lb3V0ID0gdm9pZCAwO1xuICAgIHRoaXMuc3dlZXAgPSBmdW5jdGlvbiAobWF4QWdlKSB7XG4gICAgICBpZiAobWF4QWdlID09PSB2b2lkIDApIHtcbiAgICAgICAgbWF4QWdlID0gUkVHSVNUUllfRklOQUxJWkVfQUZURVI7XG4gICAgICB9XG4gICAgICAvLyBjYW5jZWwgdGltZW91dCBzbyB3ZSBjYW4gZm9yY2Ugc3dlZXAgYW55dGltZVxuICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnN3ZWVwVGltZW91dCk7XG4gICAgICBfdGhpcy5zd2VlcFRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIF90aGlzLnJlZ2lzdHJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAocmVnaXN0cmF0aW9uLCB0b2tlbikge1xuICAgICAgICBpZiAobm93IC0gcmVnaXN0cmF0aW9uLnJlZ2lzdGVyZWRBdCA+PSBtYXhBZ2UpIHtcbiAgICAgICAgICBfdGhpcy5maW5hbGl6ZShyZWdpc3RyYXRpb24udmFsdWUpO1xuICAgICAgICAgIF90aGlzLnJlZ2lzdHJhdGlvbnNbXCJkZWxldGVcIl0odG9rZW4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChfdGhpcy5yZWdpc3RyYXRpb25zLnNpemUgPiAwKSB7XG4gICAgICAgIF90aGlzLnNjaGVkdWxlU3dlZXAoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZmluYWxpemVBbGxJbW1lZGlhdGVseSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnN3ZWVwKDApO1xuICAgIH07XG4gICAgdGhpcy5maW5hbGl6ZSA9IGZpbmFsaXplO1xuICB9XG4gIC8vIFRva2VuIGlzIGFjdHVhbGx5IHJlcXVpcmVkIHdpdGggdGhpcyBpbXBsXG4gIHZhciBfcHJvdG8gPSBUaW1lckJhc2VkRmluYWxpemF0aW9uUmVnaXN0cnkucHJvdG90eXBlO1xuICBfcHJvdG8ucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3Rlcih0YXJnZXQsIHZhbHVlLCB0b2tlbikge1xuICAgIHRoaXMucmVnaXN0cmF0aW9ucy5zZXQodG9rZW4sIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIHJlZ2lzdGVyZWRBdDogRGF0ZS5ub3coKVxuICAgIH0pO1xuICAgIHRoaXMuc2NoZWR1bGVTd2VlcCgpO1xuICB9O1xuICBfcHJvdG8udW5yZWdpc3RlciA9IGZ1bmN0aW9uIHVucmVnaXN0ZXIodG9rZW4pIHtcbiAgICB0aGlzLnJlZ2lzdHJhdGlvbnNbXCJkZWxldGVcIl0odG9rZW4pO1xuICB9XG4gIC8vIEJvdW5kIHNvIGl0IGNhbiBiZSB1c2VkIGRpcmVjdGx5IGFzIHNldFRpbWVvdXQgY2FsbGJhY2suXG4gIDtcbiAgX3Byb3RvLnNjaGVkdWxlU3dlZXAgPSBmdW5jdGlvbiBzY2hlZHVsZVN3ZWVwKCkge1xuICAgIGlmICh0aGlzLnN3ZWVwVGltZW91dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnN3ZWVwVGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5zd2VlcCwgUkVHSVNUUllfU1dFRVBfSU5URVJWQUwpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFRpbWVyQmFzZWRGaW5hbGl6YXRpb25SZWdpc3RyeTtcbn0oKTtcbnZhciBVbml2ZXJzYWxGaW5hbGl6YXRpb25SZWdpc3RyeSA9IHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSAhPT0gXCJ1bmRlZmluZWRcIiA/IEZpbmFsaXphdGlvblJlZ2lzdHJ5IDogVGltZXJCYXNlZEZpbmFsaXphdGlvblJlZ2lzdHJ5O1xuXG52YXIgb2JzZXJ2ZXJGaW5hbGl6YXRpb25SZWdpc3RyeSA9IC8qI19fUFVSRV9fKi9uZXcgVW5pdmVyc2FsRmluYWxpemF0aW9uUmVnaXN0cnkoZnVuY3Rpb24gKGFkbSkge1xuICB2YXIgX2FkbSRyZWFjdGlvbjtcbiAgKF9hZG0kcmVhY3Rpb24gPSBhZG0ucmVhY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYWRtJHJlYWN0aW9uLmRpc3Bvc2UoKTtcbiAgYWRtLnJlYWN0aW9uID0gbnVsbDtcbn0pO1xuXG4vLyBSZXF1aXJlZCBieSBTU1Igd2hlbiBoeWRyYXRpbmcgIzM2NjlcbnZhciBnZXRTZXJ2ZXJTbmFwc2hvdCA9IGZ1bmN0aW9uIGdldFNlcnZlclNuYXBzaG90KCkge307XG5mdW5jdGlvbiBjcmVhdGVSZWFjdGlvbihhZG0pIHtcbiAgYWRtLnJlYWN0aW9uID0gbmV3IG1vYnguUmVhY3Rpb24oXCJvYnNlcnZlclwiICsgYWRtLm5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICBhZG0uc3RhdGVWZXJzaW9uID0gU3ltYm9sKCk7XG4gICAgLy8gb25TdG9yZUNoYW5nZSB3b24ndCBiZSBhdmFpbGFibGUgdW50aWwgdGhlIGNvbXBvbmVudCBcIm1vdW50c1wiLlxuICAgIC8vIElmIHN0YXRlIGNoYW5nZXMgaW4gYmV0d2VlbiBpbml0aWFsIHJlbmRlciBhbmQgbW91bnQsXG4gICAgLy8gYHVzZVN5bmNFeHRlcm5hbFN0b3JlYCBzaG91bGQgaGFuZGxlIHRoYXQgYnkgY2hlY2tpbmcgdGhlIHN0YXRlIHZlcnNpb24gYW5kIGlzc3VpbmcgdXBkYXRlLlxuICAgIGFkbS5vblN0b3JlQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiBhZG0ub25TdG9yZUNoYW5nZSgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHVzZU9ic2VydmVyKHJlbmRlciwgYmFzZUNvbXBvbmVudE5hbWUpIHtcbiAgaWYgKGJhc2VDb21wb25lbnROYW1lID09PSB2b2lkIDApIHtcbiAgICBiYXNlQ29tcG9uZW50TmFtZSA9IFwib2JzZXJ2ZWRcIjtcbiAgfVxuICBpZiAoaXNVc2luZ1N0YXRpY1JlbmRlcmluZygpKSB7XG4gICAgcmV0dXJuIHJlbmRlcigpO1xuICB9XG4gIHZhciBhZG1SZWYgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYobnVsbCk7XG4gIGlmICghYWRtUmVmLmN1cnJlbnQpIHtcbiAgICAvLyBGaXJzdCByZW5kZXJcbiAgICB2YXIgX2FkbSA9IHtcbiAgICAgIHJlYWN0aW9uOiBudWxsLFxuICAgICAgb25TdG9yZUNoYW5nZTogbnVsbCxcbiAgICAgIHN0YXRlVmVyc2lvbjogU3ltYm9sKCksXG4gICAgICBuYW1lOiBiYXNlQ29tcG9uZW50TmFtZSxcbiAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlKG9uU3RvcmVDaGFuZ2UpIHtcbiAgICAgICAgLy8gRG8gTk9UIGFjY2VzcyBhZG1SZWYgaGVyZSFcbiAgICAgICAgb2JzZXJ2ZXJGaW5hbGl6YXRpb25SZWdpc3RyeS51bnJlZ2lzdGVyKF9hZG0pO1xuICAgICAgICBfYWRtLm9uU3RvcmVDaGFuZ2UgPSBvblN0b3JlQ2hhbmdlO1xuICAgICAgICBpZiAoIV9hZG0ucmVhY3Rpb24pIHtcbiAgICAgICAgICAvLyBXZSd2ZSBsb3N0IG91ciByZWFjdGlvbiBhbmQgdGhlcmVmb3JlIGFsbCBzdWJzY3JpcHRpb25zLCBvY2N1cnMgd2hlbjpcbiAgICAgICAgICAvLyAxLiBUaW1lciBiYXNlZCBmaW5hbGl6YXRpb24gcmVnaXN0cnkgZGlzcG9zZWQgcmVhY3Rpb24gYmVmb3JlIGNvbXBvbmVudCBtb3VudGVkLlxuICAgICAgICAgIC8vIDIuIFJlYWN0IFwicmUtbW91bnRzXCIgc2FtZSBjb21wb25lbnQgd2l0aG91dCBjYWxsaW5nIHJlbmRlciBpbiBiZXR3ZWVuICh0eXBpY2FsbHkgPFN0cmljdE1vZGU+KS5cbiAgICAgICAgICAvLyBXZSBoYXZlIHRvIHJlY3JlYXRlIHJlYWN0aW9uIGFuZCBzY2hlZHVsZSByZS1yZW5kZXIgdG8gcmVjcmVhdGUgc3Vic2NyaXB0aW9ucyxcbiAgICAgICAgICAvLyBldmVuIGlmIHN0YXRlIGRpZCBub3QgY2hhbmdlLlxuICAgICAgICAgIGNyZWF0ZVJlYWN0aW9uKF9hZG0pO1xuICAgICAgICAgIC8vIGBvblN0b3JlQ2hhbmdlYCB3b24ndCBmb3JjZSB1cGRhdGUgaWYgc3Vic2VxdWVudCBgZ2V0U25hcHNob3RgIHJldHVybnMgc2FtZSB2YWx1ZS5cbiAgICAgICAgICAvLyBTbyB3ZSBtYWtlIHN1cmUgdGhhdCBpcyBub3QgdGhlIGNhc2VcbiAgICAgICAgICBfYWRtLnN0YXRlVmVyc2lvbiA9IFN5bWJvbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF9hZG0kcmVhY3Rpb247XG4gICAgICAgICAgLy8gRG8gTk9UIGFjY2VzcyBhZG1SZWYgaGVyZSFcbiAgICAgICAgICBfYWRtLm9uU3RvcmVDaGFuZ2UgPSBudWxsO1xuICAgICAgICAgIChfYWRtJHJlYWN0aW9uID0gX2FkbS5yZWFjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hZG0kcmVhY3Rpb24uZGlzcG9zZSgpO1xuICAgICAgICAgIF9hZG0ucmVhY3Rpb24gPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGdldFNuYXBzaG90OiBmdW5jdGlvbiBnZXRTbmFwc2hvdCgpIHtcbiAgICAgICAgLy8gRG8gTk9UIGFjY2VzcyBhZG1SZWYgaGVyZSFcbiAgICAgICAgcmV0dXJuIF9hZG0uc3RhdGVWZXJzaW9uO1xuICAgICAgfVxuICAgIH07XG4gICAgYWRtUmVmLmN1cnJlbnQgPSBfYWRtO1xuICB9XG4gIHZhciBhZG0gPSBhZG1SZWYuY3VycmVudDtcbiAgaWYgKCFhZG0ucmVhY3Rpb24pIHtcbiAgICAvLyBGaXJzdCByZW5kZXIgb3IgcmVhY3Rpb24gd2FzIGRpc3Bvc2VkIGJ5IHJlZ2lzdHJ5IGJlZm9yZSBzdWJzY3JpYmVcbiAgICBjcmVhdGVSZWFjdGlvbihhZG0pO1xuICAgIC8vIFN0cmljdE1vZGUvQ29uY3VycmVudE1vZGUvU3VzcGVuc2UgbWF5IG1lYW4gdGhhdCBvdXIgY29tcG9uZW50IGlzXG4gICAgLy8gcmVuZGVyZWQgYW5kIGFiYW5kb25lZCBtdWx0aXBsZSB0aW1lcywgc28gd2UgbmVlZCB0byB0cmFjayBsZWFrZWRcbiAgICAvLyBSZWFjdGlvbnMuXG4gICAgb2JzZXJ2ZXJGaW5hbGl6YXRpb25SZWdpc3RyeS5yZWdpc3RlcihhZG1SZWYsIGFkbSwgYWRtKTtcbiAgfVxuICBSZWFjdF9fZGVmYXVsdC51c2VEZWJ1Z1ZhbHVlKGFkbS5yZWFjdGlvbiwgcHJpbnREZWJ1Z1ZhbHVlKTtcbiAgc2hpbS51c2VTeW5jRXh0ZXJuYWxTdG9yZShcbiAgLy8gQm90aCBvZiB0aGVzZSBtdXN0IGJlIHN0YWJsZSwgb3RoZXJ3aXNlIGl0IHdvdWxkIGtlZXAgcmVzdWJzY3JpYmluZyBldmVyeSByZW5kZXIuXG4gIGFkbS5zdWJzY3JpYmUsIGFkbS5nZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xuICAvLyByZW5kZXIgdGhlIG9yaWdpbmFsIGNvbXBvbmVudCwgYnV0IGhhdmUgdGhlXG4gIC8vIHJlYWN0aW9uIHRyYWNrIHRoZSBvYnNlcnZhYmxlcywgc28gdGhhdCByZW5kZXJpbmdcbiAgLy8gY2FuIGJlIGludmFsaWRhdGVkIChzZWUgYWJvdmUpIG9uY2UgYSBkZXBlbmRlbmN5IGNoYW5nZXNcbiAgdmFyIHJlbmRlclJlc3VsdDtcbiAgdmFyIGV4Y2VwdGlvbjtcbiAgYWRtLnJlYWN0aW9uLnRyYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgcmVuZGVyUmVzdWx0ID0gcmVuZGVyKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXhjZXB0aW9uID0gZTtcbiAgICB9XG4gIH0pO1xuICBpZiAoZXhjZXB0aW9uKSB7XG4gICAgdGhyb3cgZXhjZXB0aW9uOyAvLyByZS10aHJvdyBhbnkgZXhjZXB0aW9ucyBjYXVnaHQgZHVyaW5nIHJlbmRlcmluZ1xuICB9XG5cbiAgcmV0dXJuIHJlbmRlclJlc3VsdDtcbn1cblxudmFyIHdhcm5PYnNlcnZlck9wdGlvbnNEZXByZWNhdGVkID0gdHJ1ZTtcbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sW1wiZm9yXCJdO1xuLy8gVXNpbmcgcmVhY3QtaXMgaGFkIHNvbWUgaXNzdWVzIChhbmQgb3BlcmF0ZXMgb24gZWxlbWVudHMsIG5vdCBvbiB0eXBlcyksIHNlZSAjNjA4IC8gIzYwOVxudmFyIFJlYWN0Rm9yd2FyZFJlZlN5bWJvbCA9IGhhc1N5bWJvbCA/IC8qI19fUFVSRV9fKi9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSA6IHR5cGVvZiBSZWFjdC5mb3J3YXJkUmVmID09PSBcImZ1bmN0aW9uXCIgJiYgLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzKSB7XG4gIHJldHVybiBudWxsO1xufSlbXCIkJHR5cGVvZlwiXTtcbnZhciBSZWFjdE1lbW9TeW1ib2wgPSBoYXNTeW1ib2wgPyAvKiNfX1BVUkVfXyovU3ltYm9sW1wiZm9yXCJdKFwicmVhY3QubWVtb1wiKSA6IHR5cGVvZiBSZWFjdC5tZW1vID09PSBcImZ1bmN0aW9uXCIgJiYgLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oZnVuY3Rpb24gKHByb3BzKSB7XG4gIHJldHVybiBudWxsO1xufSlbXCIkJHR5cGVvZlwiXTtcbi8vIG4uYi4gYmFzZSBjYXNlIGlzIG5vdCB1c2VkIGZvciBhY3R1YWwgdHlwaW5ncyBvciBleHBvcnRlZCBpbiB0aGUgdHlwaW5nIGZpbGVzXG5mdW5jdGlvbiBvYnNlcnZlcihiYXNlQ29tcG9uZW50LFxuLy8gVE9ETyByZW1vdmUgaW4gbmV4dCBtYWpvclxub3B0aW9ucykge1xuICB2YXIgX29wdGlvbnMkZm9yd2FyZFJlZjtcbiAgaWYgKCB3YXJuT2JzZXJ2ZXJPcHRpb25zRGVwcmVjYXRlZCAmJiBvcHRpb25zKSB7XG4gICAgd2Fybk9ic2VydmVyT3B0aW9uc0RlcHJlY2F0ZWQgPSBmYWxzZTtcbiAgICBjb25zb2xlLndhcm4oXCJbbW9ieC1yZWFjdC1saXRlXSBgb2JzZXJ2ZXIoZm4sIHsgZm9yd2FyZFJlZjogdHJ1ZSB9KWAgaXMgZGVwcmVjYXRlZCwgdXNlIGBvYnNlcnZlcihSZWFjdC5mb3J3YXJkUmVmKGZuKSlgXCIpO1xuICB9XG4gIGlmIChSZWFjdE1lbW9TeW1ib2wgJiYgYmFzZUNvbXBvbmVudFtcIiQkdHlwZW9mXCJdID09PSBSZWFjdE1lbW9TeW1ib2wpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJbbW9ieC1yZWFjdC1saXRlXSBZb3UgYXJlIHRyeWluZyB0byB1c2UgYG9ic2VydmVyYCBvbiBhIGZ1bmN0aW9uIGNvbXBvbmVudCB3cmFwcGVkIGluIGVpdGhlciBhbm90aGVyIGBvYnNlcnZlcmAgb3IgYFJlYWN0Lm1lbW9gLiBUaGUgb2JzZXJ2ZXIgYWxyZWFkeSBhcHBsaWVzICdSZWFjdC5tZW1vJyBmb3IgeW91LlwiKTtcbiAgfVxuICAvLyBUaGUgd29ya2luZyBvZiBvYnNlcnZlciBpcyBleHBsYWluZWQgc3RlcCBieSBzdGVwIGluIHRoaXMgdGFsazogaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1jUEY0aUJlZG9GMCZmZWF0dXJlPXlvdXR1LmJlJnQ9MTMwN1xuICBpZiAoaXNVc2luZ1N0YXRpY1JlbmRlcmluZygpKSB7XG4gICAgcmV0dXJuIGJhc2VDb21wb25lbnQ7XG4gIH1cbiAgdmFyIHVzZUZvcndhcmRSZWYgPSAoX29wdGlvbnMkZm9yd2FyZFJlZiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZm9yd2FyZFJlZikgIT0gbnVsbCA/IF9vcHRpb25zJGZvcndhcmRSZWYgOiBmYWxzZTtcbiAgdmFyIHJlbmRlciA9IGJhc2VDb21wb25lbnQ7XG4gIHZhciBiYXNlQ29tcG9uZW50TmFtZSA9IGJhc2VDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgYmFzZUNvbXBvbmVudC5uYW1lO1xuICAvLyBJZiBhbHJlYWR5IHdyYXBwZWQgd2l0aCBmb3J3YXJkUmVmLCB1bndyYXAsXG4gIC8vIHNvIHdlIGNhbiBwYXRjaCByZW5kZXIgYW5kIGFwcGx5IG1lbW9cbiAgaWYgKFJlYWN0Rm9yd2FyZFJlZlN5bWJvbCAmJiBiYXNlQ29tcG9uZW50W1wiJCR0eXBlb2ZcIl0gPT09IFJlYWN0Rm9yd2FyZFJlZlN5bWJvbCkge1xuICAgIHVzZUZvcndhcmRSZWYgPSB0cnVlO1xuICAgIHJlbmRlciA9IGJhc2VDb21wb25lbnRbXCJyZW5kZXJcIl07XG4gICAgaWYgKHR5cGVvZiByZW5kZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW21vYngtcmVhY3QtbGl0ZV0gYHJlbmRlcmAgcHJvcGVydHkgb2YgRm9yd2FyZFJlZiB3YXMgbm90IGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICB9XG4gIHZhciBvYnNlcnZlckNvbXBvbmVudCA9IGZ1bmN0aW9uIG9ic2VydmVyQ29tcG9uZW50KHByb3BzLCByZWYpIHtcbiAgICByZXR1cm4gdXNlT2JzZXJ2ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlbmRlcihwcm9wcywgcmVmKTtcbiAgICB9LCBiYXNlQ29tcG9uZW50TmFtZSk7XG4gIH07XG4gIG9ic2VydmVyQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gYmFzZUNvbXBvbmVudC5kaXNwbGF5TmFtZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9ic2VydmVyQ29tcG9uZW50LCBcIm5hbWVcIiwge1xuICAgIHZhbHVlOiBiYXNlQ29tcG9uZW50Lm5hbWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICAvLyBTdXBwb3J0IGxlZ2FjeSBjb250ZXh0OiBgY29udGV4dFR5cGVzYCBtdXN0IGJlIGFwcGxpZWQgYmVmb3JlIGBtZW1vYFxuICBpZiAoYmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZXMpIHtcbiAgICBvYnNlcnZlckNvbXBvbmVudC5jb250ZXh0VHlwZXMgPSBiYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlcztcbiAgfVxuICBpZiAodXNlRm9yd2FyZFJlZikge1xuICAgIC8vIGBmb3J3YXJkUmVmYCBtdXN0IGJlIGFwcGxpZWQgcHJpb3IgYG1lbW9gXG4gICAgLy8gYGZvcndhcmRSZWYob2JzZXJ2ZXIoY21wKSlgIHRocm93czpcbiAgICAvLyBcImZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHJlY2VpdmVkIGEgYG1lbW9gIGNvbXBvbmVudC4gSW5zdGVhZCBvZiBmb3J3YXJkUmVmKG1lbW8oLi4uKSksIHVzZSBtZW1vKGZvcndhcmRSZWYoLi4uKSlcIlxuICAgIG9ic2VydmVyQ29tcG9uZW50ID0gUmVhY3QuZm9yd2FyZFJlZihvYnNlcnZlckNvbXBvbmVudCk7XG4gIH1cbiAgLy8gbWVtbzsgd2UgYXJlIG5vdCBpbnRlcmVzdGVkIGluIGRlZXAgdXBkYXRlc1xuICAvLyBpbiBwcm9wczsgd2UgYXNzdW1lIHRoYXQgaWYgZGVlcCBvYmplY3RzIGFyZSBjaGFuZ2VkLFxuICAvLyB0aGlzIGlzIGluIG9ic2VydmFibGVzLCB3aGljaCB3b3VsZCBoYXZlIGJlZW4gdHJhY2tlZCBhbnl3YXlcbiAgb2JzZXJ2ZXJDb21wb25lbnQgPSBSZWFjdC5tZW1vKG9ic2VydmVyQ29tcG9uZW50KTtcbiAgY29weVN0YXRpY1Byb3BlcnRpZXMoYmFzZUNvbXBvbmVudCwgb2JzZXJ2ZXJDb21wb25lbnQpO1xuICB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9ic2VydmVyQ29tcG9uZW50LCBcImNvbnRleHRUeXBlc1wiLCB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCgpIHtcbiAgICAgICAgdmFyIF90aGlzJHR5cGUsIF90aGlzJHR5cGUyO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbbW9ieC1yZWFjdC1saXRlXSBgXCIgKyAodGhpcy5kaXNwbGF5TmFtZSB8fCAoKF90aGlzJHR5cGUgPSB0aGlzLnR5cGUpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyR0eXBlLmRpc3BsYXlOYW1lKSB8fCAoKF90aGlzJHR5cGUyID0gdGhpcy50eXBlKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkdHlwZTIubmFtZSkgfHwgXCJDb21wb25lbnRcIikgKyBcIi5jb250ZXh0VHlwZXNgIG11c3QgYmUgc2V0IGJlZm9yZSBhcHBseWluZyBgb2JzZXJ2ZXJgLlwiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gb2JzZXJ2ZXJDb21wb25lbnQ7XG59XG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbXJpZGd3YXkvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvYmxvYi9tYXN0ZXIvc3JjL2luZGV4LmpzXG52YXIgaG9pc3RCbGFja0xpc3QgPSB7XG4gICQkdHlwZW9mOiB0cnVlLFxuICByZW5kZXI6IHRydWUsXG4gIGNvbXBhcmU6IHRydWUsXG4gIHR5cGU6IHRydWUsXG4gIC8vIERvbid0IHJlZGVmaW5lIGBkaXNwbGF5TmFtZWAsXG4gIC8vIGl0J3MgZGVmaW5lZCBhcyBnZXR0ZXItc2V0dGVyIHBhaXIgb24gYG1lbW9gIChzZWUgIzMxOTIpLlxuICBkaXNwbGF5TmFtZTogdHJ1ZVxufTtcbmZ1bmN0aW9uIGNvcHlTdGF0aWNQcm9wZXJ0aWVzKGJhc2UsIHRhcmdldCkge1xuICBPYmplY3Qua2V5cyhiYXNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIWhvaXN0QmxhY2tMaXN0W2tleV0pIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBrZXkpKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBPYnNlcnZlckNvbXBvbmVudChfcmVmKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgcmVuZGVyID0gX3JlZi5yZW5kZXI7XG4gIHZhciBjb21wb25lbnQgPSBjaGlsZHJlbiB8fCByZW5kZXI7XG4gIGlmICh0eXBlb2YgY29tcG9uZW50ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gdXNlT2JzZXJ2ZXIoY29tcG9uZW50KTtcbn1cbntcbiAgT2JzZXJ2ZXJDb21wb25lbnQucHJvcFR5cGVzID0ge1xuICAgIGNoaWxkcmVuOiBPYnNlcnZlclByb3BzQ2hlY2ssXG4gICAgcmVuZGVyOiBPYnNlcnZlclByb3BzQ2hlY2tcbiAgfTtcbn1cbk9ic2VydmVyQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gXCJPYnNlcnZlclwiO1xuZnVuY3Rpb24gT2JzZXJ2ZXJQcm9wc0NoZWNrKHByb3BzLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgdmFyIGV4dHJhS2V5ID0ga2V5ID09PSBcImNoaWxkcmVuXCIgPyBcInJlbmRlclwiIDogXCJjaGlsZHJlblwiO1xuICB2YXIgaGFzUHJvcCA9IHR5cGVvZiBwcm9wc1trZXldID09PSBcImZ1bmN0aW9uXCI7XG4gIHZhciBoYXNFeHRyYVByb3AgPSB0eXBlb2YgcHJvcHNbZXh0cmFLZXldID09PSBcImZ1bmN0aW9uXCI7XG4gIGlmIChoYXNQcm9wICYmIGhhc0V4dHJhUHJvcCkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoXCJNb2JYIE9ic2VydmVyOiBEbyBub3QgdXNlIGNoaWxkcmVuIGFuZCByZW5kZXIgaW4gdGhlIHNhbWUgdGltZSBpbmBcIiArIGNvbXBvbmVudE5hbWUpO1xuICB9XG4gIGlmIChoYXNQcm9wIHx8IGhhc0V4dHJhUHJvcCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBuZXcgRXJyb3IoXCJJbnZhbGlkIHByb3AgYFwiICsgcHJvcEZ1bGxOYW1lICsgXCJgIG9mIHR5cGUgYFwiICsgdHlwZW9mIHByb3BzW2tleV0gKyBcImAgc3VwcGxpZWQgdG9cIiArIFwiIGBcIiArIGNvbXBvbmVudE5hbWUgKyBcImAsIGV4cGVjdGVkIGBmdW5jdGlvbmAuXCIpO1xufVxuXG5mdW5jdGlvbiB1c2VMb2NhbE9ic2VydmFibGUoaW5pdGlhbGl6ZXIsIGFubm90YXRpb25zKSB7XG4gIHJldHVybiBSZWFjdC51c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG1vYngub2JzZXJ2YWJsZShpbml0aWFsaXplcigpLCBhbm5vdGF0aW9ucywge1xuICAgICAgYXV0b0JpbmQ6IHRydWVcbiAgICB9KTtcbiAgfSlbMF07XG59XG5cbmZ1bmN0aW9uIHVzZUFzT2JzZXJ2YWJsZVNvdXJjZShjdXJyZW50KSB7XG4gIHVzZURlcHJlY2F0ZWQoXCJbbW9ieC1yZWFjdC1saXRlXSAndXNlQXNPYnNlcnZhYmxlU291cmNlJyBpcyBkZXByZWNhdGVkLCBwbGVhc2Ugc3RvcmUgdGhlIHZhbHVlcyBkaXJlY3RseSBpbiBhbiBvYnNlcnZhYmxlLCBmb3IgZXhhbXBsZSBieSB1c2luZyAndXNlTG9jYWxPYnNlcnZhYmxlJywgYW5kIHN5bmMgZnV0dXJlIHVwZGF0ZXMgdXNpbmcgJ3VzZUVmZmVjdCcgd2hlbiBuZWVkZWQuIFNlZSB0aGUgUkVBRE1FIGZvciBleGFtcGxlcy5cIik7XG4gIHZhciBfdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbW9ieC5vYnNlcnZhYmxlKGN1cnJlbnQsIHt9LCB7XG4gICAgICAgIGRlZXA6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9KSxcbiAgICByZXMgPSBfdXNlU3RhdGVbMF07XG4gIG1vYngucnVuSW5BY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgIE9iamVjdC5hc3NpZ24ocmVzLCBjdXJyZW50KTtcbiAgfSk7XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHVzZUxvY2FsU3RvcmUoaW5pdGlhbGl6ZXIsIGN1cnJlbnQpIHtcbiAge1xuICAgIHVzZURlcHJlY2F0ZWQoXCJbbW9ieC1yZWFjdC1saXRlXSAndXNlTG9jYWxTdG9yZScgaXMgZGVwcmVjYXRlZCwgdXNlICd1c2VMb2NhbE9ic2VydmFibGUnIGluc3RlYWQuXCIpO1xuICB9XG4gIHZhciBzb3VyY2UgPSBjdXJyZW50ICYmIHVzZUFzT2JzZXJ2YWJsZVNvdXJjZShjdXJyZW50KTtcbiAgcmV0dXJuIFJlYWN0LnVzZVN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbW9ieC5vYnNlcnZhYmxlKGluaXRpYWxpemVyKHNvdXJjZSksIHVuZGVmaW5lZCwge1xuICAgICAgYXV0b0JpbmQ6IHRydWVcbiAgICB9KTtcbiAgfSlbMF07XG59XG5cbnZhciBfb2JzZXJ2ZXJGaW5hbGl6YXRpb247XG5vYnNlcnZlckJhdGNoaW5nKHJlYWN0RG9tLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzKTtcbnZhciBjbGVhclRpbWVycyA9IChfb2JzZXJ2ZXJGaW5hbGl6YXRpb24gPSBvYnNlcnZlckZpbmFsaXphdGlvblJlZ2lzdHJ5W1wiZmluYWxpemVBbGxJbW1lZGlhdGVseVwiXSkgIT0gbnVsbCA/IF9vYnNlcnZlckZpbmFsaXphdGlvbiA6IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gdXNlT2JzZXJ2ZXIkMShmbiwgYmFzZUNvbXBvbmVudE5hbWUpIHtcbiAgaWYgKGJhc2VDb21wb25lbnROYW1lID09PSB2b2lkIDApIHtcbiAgICBiYXNlQ29tcG9uZW50TmFtZSA9IFwib2JzZXJ2ZWRcIjtcbiAgfVxuICB7XG4gICAgdXNlRGVwcmVjYXRlZChcIlttb2J4LXJlYWN0LWxpdGVdICd1c2VPYnNlcnZlcihmbiknIGlzIGRlcHJlY2F0ZWQuIFVzZSBgPE9ic2VydmVyPntmbn08L09ic2VydmVyPmAgaW5zdGVhZCwgb3Igd3JhcCB0aGUgZW50aXJlIGNvbXBvbmVudCBpbiBgb2JzZXJ2ZXJgLlwiKTtcbiAgfVxuICByZXR1cm4gdXNlT2JzZXJ2ZXIoZm4sIGJhc2VDb21wb25lbnROYW1lKTtcbn1cbmZ1bmN0aW9uIHVzZVN0YXRpY1JlbmRlcmluZyhlbmFibGUpIHtcbiAge1xuICAgIGNvbnNvbGUud2FybihcIlttb2J4LXJlYWN0LWxpdGVdICd1c2VTdGF0aWNSZW5kZXJpbmcnIGlzIGRlcHJlY2F0ZWQsIHVzZSAnZW5hYmxlU3RhdGljUmVuZGVyaW5nJyBpbnN0ZWFkXCIpO1xuICB9XG4gIGVuYWJsZVN0YXRpY1JlbmRlcmluZyhlbmFibGUpO1xufVxuXG5leHBvcnRzLk9ic2VydmVyID0gT2JzZXJ2ZXJDb21wb25lbnQ7XG5leHBvcnRzLl9vYnNlcnZlckZpbmFsaXphdGlvblJlZ2lzdHJ5ID0gb2JzZXJ2ZXJGaW5hbGl6YXRpb25SZWdpc3RyeTtcbmV4cG9ydHMuY2xlYXJUaW1lcnMgPSBjbGVhclRpbWVycztcbmV4cG9ydHMuZW5hYmxlU3RhdGljUmVuZGVyaW5nID0gZW5hYmxlU3RhdGljUmVuZGVyaW5nO1xuZXhwb3J0cy5pc09ic2VydmVyQmF0Y2hlZCA9IGlzT2JzZXJ2ZXJCYXRjaGVkO1xuZXhwb3J0cy5pc1VzaW5nU3RhdGljUmVuZGVyaW5nID0gaXNVc2luZ1N0YXRpY1JlbmRlcmluZztcbmV4cG9ydHMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbmV4cG9ydHMub2JzZXJ2ZXJCYXRjaGluZyA9IG9ic2VydmVyQmF0Y2hpbmc7XG5leHBvcnRzLnVzZUFzT2JzZXJ2YWJsZVNvdXJjZSA9IHVzZUFzT2JzZXJ2YWJsZVNvdXJjZTtcbmV4cG9ydHMudXNlTG9jYWxPYnNlcnZhYmxlID0gdXNlTG9jYWxPYnNlcnZhYmxlO1xuZXhwb3J0cy51c2VMb2NhbFN0b3JlID0gdXNlTG9jYWxTdG9yZTtcbmV4cG9ydHMudXNlT2JzZXJ2ZXIgPSB1c2VPYnNlcnZlciQxO1xuZXhwb3J0cy51c2VTdGF0aWNSZW5kZXJpbmcgPSB1c2VTdGF0aWNSZW5kZXJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2J4cmVhY3RsaXRlLmNqcy5kZXZlbG9wbWVudC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mobx-react-lite/dist/mobxreactlite.cjs.development.js\n");

/***/ })

};
;